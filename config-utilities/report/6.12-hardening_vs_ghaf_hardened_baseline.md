# Kernel Config Comparision

## Table:

| Index | Config Name | Description | kernel-6.12-hardening.config  | ghaf_host_hardened_baseline-x86 |
|---|---|---|---|---|
| 1 | CONFIG_BUG | Disabling this option eliminates support for BUG and WARN, reducing <br /> the size of your kernel image and potentially quietly ignoring <br /> numerous fatal conditions. You should only consider disabling this <br /> option for embedded systems with no facilities for reporting errors. <br /> Just say Y. | y  | y |
| 2 | CONFIG_STRICT_KERNEL_RWX | If this is set, kernel text and rodata memory will be made read-only, <br /> and non-text memory will be made non-executable. This provides <br /> protection against certain security exploits (e.g. executing the heap <br /> or modifying text) | y  | y |
| 3 | CONFIG_STRICT_MODULE_RWX | If this is set, module text and rodata memory will be made read-only, <br /> and non-text memory will be made non-executable. This provides <br /> protection against certain security exploits (e.g. writing to text) | y  | y |
| 4 | CONFIG_VMAP_STACK | Enable this if you want the use virtually-mapped kernel stacks <br /> with guard pages.  This causes kernel stack overflows to be <br /> caught immediately rather than causing difficult-to-diagnose <br /> corruption. | y  | y |
| 5 | CONFIG_RANDOMIZE_BASE | In support of Kernel Address Space Layout Randomization (KASLR), <br /> this randomizes the physical address at which the kernel image <br /> is decompressed and the virtual address where the kernel <br /> image is mapped, as a security feature that deters exploit <br /> attempts relying on knowledge of the location of kernel <br /> code internals. | y  | y |
| 6 | CONFIG_RANDOMIZE_MEMORY | Randomizes the base virtual address of kernel memory sections <br /> (physical memory mapping, vmalloc & vmemmap). This security feature <br /> makes exploits relying on predictable memory locations less reliable. | y  | y |
| 7 | CONFIG_SLAB_FREELIST_RANDOM | Randomizes the freelist order used on creating new pages. This <br /> security feature reduces the predictability of the kernel slab <br /> allocator against heap overflows. | y  | y |
| 8 | CONFIG_SLAB_FREELIST_HARDENED | Many kernel heap attacks try to target slab cache metadata and <br /> other infrastructure. This options makes minor performance <br /> sacrifices to harden the kernel slab allocator against common <br /> freelist exploit methods. | y  | y |
| 9 | CONFIG_SLAB_BUCKETS | Kernel heap attacks frequently depend on being able to create <br /> specifically-sized allocations with user-controlled contents <br /> that will be allocated into the same kmalloc bucket as a <br /> target object. To avoid sharing these allocation buckets, <br /> provide an explicitly separated set of buckets to be used for <br /> user-controlled allocations. This may very slightly increase <br /> memory fragmentation, though in practice it's only a handful <br /> of extra pages since the bulk of user-controlled allocations <br /> are relatively long-lived. | y  | NOT AVAILABLE! |
| 10 | CONFIG_SHUFFLE_PAGE_ALLOCATOR | Randomization of the page allocator improves the average <br /> utilization of a direct-mapped memory-side-cache. See section <br /> 5.2.27 Heterogeneous Memory Attribute Table (HMAT) in the ACPI <br /> 6.2a specification for an example of how a platform advertises <br /> the presence of a memory-side-cache. There are also incidental <br /> security benefits as it reduces the predictability of page <br /> allocations to compliment SLAB_FREELIST_RANDOM, but the <br /> default granularity of shuffling on the MAX_PAGE_ORDER i.e, 10th <br /> order of pages is selected based on cache utilization benefits <br /> on x86. | y  | y |
| 11 | CONFIG_RANDOM_KMALLOC_CACHES | A hardening feature that creates multiple copies of slab caches for <br /> normal kmalloc allocation and makes kmalloc randomly pick one based <br /> on code address, which makes the attackers more difficult to spray <br /> vulnerable memory objects on the heap for the purpose of exploiting <br /> memory vulnerabilities. | y  | DEFAULT |
| 12 | CONFIG_PAGE_TABLE_CHECK | Check that anonymous page is not being mapped twice with read write <br /> permissions. Check that anonymous and file pages are not being <br /> erroneously shared. Since the checking is performed at the time <br /> entries are added and removed to user page tables, leaking, corruption <br /> and double mapping problems are detected synchronously. | y  | DEFAULT |
| 13 | CONFIG_PAGE_TABLE_CHECK_ENFORCED | Always enable page table checking.  By default the page table checking <br /> is disabled, and can be optionally enabled via page_table_check=on <br /> kernel parameter. This config enforces that page table check is always <br /> enabled. | y  | NOT AVAILABLE! |
| 14 | CONFIG_RANDOMIZE_KSTACK_OFFSET_DEFAULT | Kernel stack offset randomization is controlled by kernel boot param <br /> "randomize_kstack_offset=on/off", and this config chooses the default <br /> boot state. | y  | y |
| 15 | CONFIG_STACKPROTECTOR | This option turns on the "stack-protector" GCC feature. This <br /> feature puts, at the beginning of functions, a canary value on <br /> the stack just before the return address, and validates <br /> the value just before actually returning.  Stack based buffer <br /> overflows (that need to overwrite this return address) now also <br /> overwrite the canary, which gets detected and the attack is then <br /> neutralized via a kernel panic. | y  | y |
| 16 | CONFIG_STACKPROTECTOR_STRONG | Functions will have the stack-protector canary logic added in any <br /> of the following conditions: | y  | y |
| 17 | CONFIG_HARDENED_USERCOPY | This option checks for obviously wrong memory regions when <br /> copying memory to/from the kernel (via copy_to_user() and <br /> copy_from_user() functions) by rejecting memory ranges that <br /> are larger than the specified heap object, span multiple <br /> separately allocated pages, are not on the process stack, <br /> or are part of the kernel text. This prevents entire classes <br /> of heap overflow exploits and similar kernel memory exposures. | y  | y |
| 18 | CONFIG_FORTIFY_SOURCE | Detect overflows of buffers in common string and memory functions <br /> where the compiler can determine and validate the buffer sizes. | y  | y |
| 19 | CONFIG_UBSAN | This option enables the Undefined Behaviour sanity checker. <br /> Compile-time instrumentation is used to detect various undefined <br /> behaviours at runtime. For more details, see: <br /> Documentation/dev-tools/ubsan.rst | y  | y |
| 20 | CONFIG_UBSAN_TRAP | Building kernels with Sanitizer features enabled tends to grow <br /> the kernel size by around 5%, due to adding all the debugging <br /> text on failure paths. To avoid this, Sanitizer instrumentation <br /> can just issue a trap. This reduces the kernel size overhead but <br /> turns all warnings (including potentially harmless conditions) <br /> into full exceptions that abort the running kernel code <br /> (regardless of context, locks held, etc), which may destabilize <br /> the system. For some system builders this is an acceptable <br /> trade-off. | y  | y |
| 21 | CONFIG_UBSAN_BOUNDS | This option enables detection of directly indexed out of bounds <br /> array accesses, where the array size is known at compile time. <br /> Note that this does not protect array overflows via bad calls <br /> to the {str,mem}*cpy() family of functions (that is addressed <br /> by FORTIFY_SOURCE). | y  | y |
| 22 | CONFIG_UBSAN_SHIFT | This option enables -fsanitize=shift which checks for bit-shift <br /> operations that overflow to the left or go switch to negative <br /> for signed types. | DEFAULT  | DEFAULT |
| 23 | CONFIG_UBSAN_DIV_ZERO | This option enables -fsanitize=integer-divide-by-zero which checks <br /> for integer division by zero. This is effectively redundant with the <br /> kernel's existing exception handling, though it can provide greater <br /> debugging information under UBSAN_REPORT_FULL. | DEFAULT  | DEFAULT |
| 24 | CONFIG_UBSAN_UNREACHABLE | This option enables -fsanitize=unreachable which checks for control <br /> flow reaching an expected-to-be-unreachable position. | DEFAULT  | NOT AVAILABLE! |
| 25 | CONFIG_UBSAN_SIGNED_WRAP | This option enables -fsanitize=signed-integer-overflow which checks <br /> for wrap-around of any arithmetic operations with signed integers. <br /> This currently performs nearly no instrumentation due to the <br /> kernel's use of -fno-strict-overflow which converts all would-be <br /> arithmetic undefined behavior into wrap-around arithmetic. Future <br /> sanitizer versions will allow for wrap-around checking (rather than <br /> exclusively undefined behavior). | DEFAULT  | NOT AVAILABLE! |
| 26 | CONFIG_UBSAN_BOOL | This option enables -fsanitize=bool which checks for boolean values being <br /> loaded that are neither 0 nor 1. | DEFAULT  | DEFAULT |
| 27 | CONFIG_UBSAN_ENUM | This option enables -fsanitize=enum which checks for values being loaded <br /> into an enum that are outside the range of given values for the given enum. | DEFAULT  | DEFAULT |
| 28 | CONFIG_UBSAN_ALIGNMENT | This option enables the check of unaligned memory accesses. <br /> Enabling this option on architectures that support unaligned <br /> accesses may produce a lot of false positives. | DEFAULT  | NOT AVAILABLE! |
| 29 | CONFIG_KFENCE | KFENCE is a low-overhead sampling-based detector of heap out-of-bounds <br /> access, use-after-free, and invalid-free errors. KFENCE is designed <br /> to have negligible cost to permit enabling it in production <br /> environments. | y  | y |
| 30 | CONFIG_LIST_HARDENED | Minimal integrity checking in the linked-list manipulation routines <br /> to catch memory corruptions that are not guaranteed to result in an <br /> immediate access fault. | y  | y |
| 31 | CONFIG_INIT_ON_ALLOC_DEFAULT_ON | This has the effect of setting "init_on_alloc=1" on the kernel <br /> command line. This can be disabled with "init_on_alloc=0". <br /> When "init_on_alloc" is enabled, all page allocator and slab <br /> allocator memory will be zeroed when allocated, eliminating <br /> many kinds of "uninitialized heap memory" flaws, especially <br /> heap content exposures. The performance impact varies by <br /> workload, but most cases see <1% impact. Some synthetic <br /> workloads have measured as high as 7%. | y  | y |
| 32 | CONFIG_INIT_STACK_ALL_ZERO | Initializes everything on the stack (including padding) <br /> with a zero value. This is intended to eliminate all <br /> classes of uninitialized stack variable exploits and <br /> information exposures, even variables that were warned <br /> about having been left uninitialized. | y  | y |
| 33 | CONFIG_RESET_ATTACK_MITIGATION | Request that the firmware clear the contents of RAM after a reboot <br /> using the TCG Platform Reset Attack Mitigation specification. This <br /> protects against an attacker forcibly rebooting the system while it <br /> still contains secrets in RAM, booting another OS and extracting the <br /> secrets. This should only be enabled when userland is configured to <br /> clear the MemoryOverwriteRequest flag on clean shutdown after secrets <br /> have been evicted, since otherwise it will trigger even on clean <br /> reboots. | y  | y |
| 34 | CONFIG_EFI_DISABLE_PCI_DMA | Disable the busmaster bit in the control register on all PCI bridges <br /> while calling ExitBootServices() and passing control to the runtime <br /> kernel. System firmware may configure the IOMMU to prevent malicious <br /> PCI devices from being able to attack the OS via DMA. However, since <br /> firmware can't guarantee that the OS is IOMMU-aware, it will tear <br /> down IOMMU configuration when ExitBootServices() is called. This <br /> leaves a window between where a hostile device could still cause <br /> damage before Linux configures the IOMMU again. | y  | y |
| 35 | CONFIG_IOMMU_SUPPORT | Say Y here if you want to compile device drivers for IO Memory <br /> Management Units into the kernel. These devices usually allow to <br /> remap DMA requests and/or remap interrupts from other devices on the <br /> system. | y  | y |
| 36 | CONFIG_IOMMU_DEFAULT_DMA_STRICT | Trusted devices use translation to restrict their access to only <br /> DMA-mapped pages, with strict TLB invalidation on unmap. Equivalent <br /> to passing "iommu.passthrough=0 iommu.strict=1" on the command line. | y  | y |
| 37 | CONFIG_STRICT_DEVMEM | If this option is disabled, you allow userspace (root) access to all <br /> of memory, including kernel and userspace memory. Accidental <br /> access to this is obviously disastrous, but specific access can <br /> be used by people debugging the kernel. Note that with PAT support <br /> enabled, even in this case there are restrictions on /dev/mem <br /> use due to the cache aliasing requirements. | y  | DEFAULT |
| 38 | CONFIG_IO_STRICT_DEVMEM | If this option is disabled, you allow userspace (root) access to all <br /> io-memory regardless of whether a driver is actively using that <br /> range.  Accidental access to this is obviously disastrous, but <br /> specific access can be used by people debugging kernel drivers. | y  | NOT AVAILABLE! |
| 39 | CONFIG_SECCOMP | This kernel feature is useful for number crunching applications <br /> that may need to handle untrusted bytecode during their <br /> execution. By using pipes or other transports made available <br /> to the process as file descriptors supporting the read/write <br /> syscalls, it's possible to isolate those applications in their <br /> own address space using seccomp. Once seccomp is enabled via <br /> prctl(PR_SET_SECCOMP) or the seccomp() syscall, it cannot be <br /> disabled and the task is only allowed to execute a few safe <br /> syscalls defined by each seccomp mode. | y  | y |
| 40 | CONFIG_SECCOMP_FILTER | Enable tasks to build secure computing environments defined <br /> in terms of Berkeley Packet Filter programs which implement <br /> task-defined system call filtering polices. | y  | y |
| 41 | CONFIG_SYN_COOKIES | Normal TCP/IP networking is open to an attack known as "SYN <br /> flooding". This denial-of-service attack prevents legitimate remote <br /> users from being able to connect to your computer during an ongoing <br /> attack and requires very little work from the attacker, who can <br /> operate from anywhere on the Internet. | y  | NOT AVAILABLE! |
| 42 | CONFIG_CFI_CLANG | This option enables Clang's forward-edge Control Flow Integrity <br /> (CFI) checking, where the compiler injects a runtime check to each <br /> indirect function call to ensure the target is a valid function with <br /> the correct static type. This restricts possible call targets and <br /> makes it more difficult for an attacker to exploit bugs that allow <br /> the modification of stored function pointers. More information can be <br /> found from Clang's documentation: | y  | NOT AVAILABLE! |
| 43 | CONFIG_CFI_PERMISSIVE | When selected, Control Flow Integrity (CFI) violations result in a <br /> warning instead of a kernel panic. This option should only be used <br /> for finding indirect call type mismatches during development. | DEFAULT  | NOT AVAILABLE! |
| 44 | CONFIG_LDISC_AUTOLOAD | Historically the kernel has always automatically loaded any <br /> line discipline that is in a kernel module when a user asks <br /> for it to be loaded with the TIOCSETD ioctl, or through other <br /> means.  This is not always the best thing to do on systems <br /> where you know you will not be using some of the more <br /> "ancient" line disciplines, so prevent the kernel from doing <br /> this unless the request is coming from a process with the <br /> CAP_SYS_MODULE permissions. | DEFAULT  | DEFAULT |
| 45 | CONFIG_COMPAT_BRK | Randomizing heap placement makes heap exploits harder, but it <br /> also breaks ancient binaries (including anything libc5 based). <br /> This option changes the bootup default to heap randomization <br /> disabled, and can be overridden at runtime by setting <br /> /proc/sys/kernel/randomize_va_space to 2. | DEFAULT  | DEFAULT |
| 46 | CONFIG_PROC_KCORE | Provides a virtual ELF core file of the live kernel.  This can <br /> be read with gdb and other ELF tools.  No modifications can be <br /> made using this mechanism. | DEFAULT  | DEFAULT |
| 47 | CONFIG_COMPAT_VDSO | Certain buggy versions of glibc will crash if they are <br /> presented with a 32-bit vDSO that is not mapped at the address <br /> indicated in its segment table. | DEFAULT  | NOT AVAILABLE! |
| 48 | CONFIG_LEGACY_PTYS | A pseudo terminal (PTY) is a software device consisting of two <br /> halves: a master and a slave. The slave device behaves identical to <br /> a physical terminal; the master device is used by a process to <br /> read data from and write data to the slave, thereby emulating a <br /> terminal. Typical programs for the master side are telnet servers <br /> and xterms. | DEFAULT  | DEFAULT |
